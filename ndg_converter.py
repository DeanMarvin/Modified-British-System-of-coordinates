# -*- coding: utf-8 -*-
"""
/***************************************************************************
 MbsTransform
                                 A QGIS plugin
 Convert NDG Coordinates to specified Coordinate Reference System
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-08-09
        git sha              : $Format:%H$
        copyright            : (C) 2021 by Marvin Ike
        email                : ike@luftbilddatenbank.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, QSizeF, QPoint
from qgis.PyQt.QtGui import QIcon, QTextDocument, QColor
from qgis.PyQt.QtWidgets import QAction, QLineEdit

from qgis.core import QgsProject, Qgis, QgsTextAnnotation, QgsAnnotationManager, QgsCoordinateReferenceSystem, \
    QgsPointXY, QgsSimpleMarkerSymbolLayer, QgsMarkerSymbol, QgsTextFormat

from pyproj import transform, Proj
import pyproj

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .showxydialog import showXYDialog
import os.path


class MbsTransform:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'MbsTransform_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&NDG Converter')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('MbsTransform', message)

    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            pass
            # self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/Modified-British-System-of-coordinates/show_marker.png'
        self.add_action(
            icon_path,
            text=self.tr(u'NDG Converter'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # Create lineEdit for coordinates input
        self.lineEdit = QLineEdit(self.iface.mainWindow())
        self.lineEdit.setFixedWidth(80)

        # Create action add Layer to Canvas
        self.actionAddLayer = QAction(
            QIcon(":/plugins/Modified-British-System-of-coordinates/show_marker.png"),
            "add NDG-Coordinate to map",
            self.iface.mainWindow()
        )
        self.actionAddLayer.triggered.connect(self.show_coordinates)

        # Create action to remove Layer from Canvas
        self.actionRemoveLayer = QAction(
            QIcon(":/plugins/Modified-British-System-of-coordinates/hide_marker.png"),
            "clear map",
            self.iface.mainWindow()
        )
        self.actionRemoveLayer.triggered.connect(self.clear_annotation)

        # Create action to show XY-Coordinates
        self.actionShowXY = QAction(
            QIcon(":/plugins/Modified-British-System-of-coordinates/show_xy.png"),
            "show XY-Coordinates in Window",
            self.iface.mainWindow()
        )
        self.actionShowXY.triggered.connect(self.show_coordinates)

        # Create toolbar for this plugin
        self.toolbar = self.iface.addToolBar("NDG Converter")
        self.toolbar.addWidget(self.lineEdit)
        self.toolbar.addAction(self.actionAddLayer)
        self.toolbar.addAction(self.actionRemoveLayer)
        self.toolbar.addAction(self.actionShowXY)

        self.dialogShowXY = showXYDialog()

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""

        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&NDG Converter'),
                action)
            self.iface.removeToolBarIcon(action)

    @staticmethod
    def project():
        """Return QGSProject"""

        return QgsProject.instance()

    @staticmethod
    def crs_modified_lambert():
        """define the spatial reference of the Modified British System coordinate"""

        crs_modified_lambert = Proj(
            '+proj=lcc +lat_0=49.5 +lon_0=7.737208 +lat_1=49.5 +lat_2=49.5 +x_0=600000 +y_0=300000 +k_0=0.99950908 +a=6376523 +rf=308.64 +units=m +no_defs +type=crs')

        return crs_modified_lambert

    def output_spatial_reference_system(self):
        """Return the output spatial reference system from current project crs"""

        project_crs = str(self.project().crs())[31:-1]
        return project_crs

    def check_mbs_coordinate(self, input_coordinate):
        """check validation of input-coordinate"""

        try:
            failures = []

            if len(input_coordinate) % 2 != 0:
                failures.append('Ungerade Anzahl an Koordinaten-Stellen.')
            if input_coordinate[0].islower() is False:
                failures.append('Erste Koordinaten-Stelle muss ein Kleinbuchstabe sein.')
            elif input_coordinate[0] not in ['v', 'w', 'x', 'q', 'r', 's', 'n']:
                failures.append('Erste Stelle außerhalb des gültigen Bereichs (n, q, r, s, v, w, x).')
            if input_coordinate[1].isupper() is False:
                failures.append('Zweite Koordinaten-Stelle muss ein Großbuchstabe sein.')
            elif input_coordinate[1] not in ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
                                             'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z']:
                failures.append('Zweite Stelle außerhalb des gültigen Bereichs (A, B, C, D, E, F, G, H, J, K, L, M, '
                                'N, O, P, Q, R, S, T, U, V, W, X, Y, Z.')
            if any(char.isalpha() for char in input_coordinate[2:]) is True:
                failures.append('Die Koordinate enthält mehr als zwei Buchstaben.')

            return failures

        except IndexError:
            self.iface.messageBar().pushMessage("Error", "Gültige Koordinate eingeben.", level=Qgis.Critical,
                                                duration=5)

    @staticmethod
    def mbs_to_crs(in_coordinate, crs_modified_lambert, crs_specified):
        """Convert mbs to specified crs coordinates"""
        try:
            # split Coordinate to according to Modified British System
            km500_square = in_coordinate[0]
            km100_square = in_coordinate[1]
            detailed_square = in_coordinate[2:]

            # define Squares in m from origin according to Modified British System
            # pay attention to the special order of line, ABCDE is the bottom row
            km500_square_dict = {'v': [0, 0], 'w': [500000, 0], 'x': [1000000, 0],
                                 'q': [0, 500000], 'r': [500000, 500000], 's': [1000000, 500000],
                                 'n': [1000000, 1000000]}

            km100_square_dict = {'F': [0, 400000], 'G': [100000, 400000], 'H': [200000, 400000],
                                 'J': [300000, 400000], 'K': [400000, 400000], 'L': [0, 300000],
                                 'M': [100000, 300000], 'N': [200000, 300000], 'O': [300000, 300000],
                                 'P': [400000, 300000], 'Q': [0, 200000], 'R': [100000, 200000],
                                 'S': [200000, 200000], 'T': [300000, 200000], 'U': [400000, 200000],
                                 'V': [0, 100000], 'W': [100000, 100000], 'X': [200000, 100000],
                                 'Y': [300000, 100000], 'Z': [400000, 100000], 'A': [0, 0],
                                 'B': [100000, 0], 'C': [200000, 0], 'D': [300000, 0],
                                 'E': [400000, 0]}

            # get the 500 km root of coordinate
            lambert_x_coordinate = km500_square_dict[km500_square][0]
            lambert_y_coordinate = km500_square_dict[km500_square][1]

            # get the 100 km root of coordinate
            lambert_x_coordinate += km100_square_dict[km100_square][0]
            lambert_y_coordinate += km100_square_dict[km100_square][1]

            # depending on the detail-level of the coordinate (4-10 digits)
            # the digits have to match this level (1-1000 m)
            factor = [1000, 100, 10, 1][(len(detailed_square) // 2) - 2]

            # get the detailed coordinate, depending on its accuracy (see factor 1-1000 m)
            lambert_x_coordinate = lambert_x_coordinate + int(detailed_square[:len(detailed_square) // 2]) * factor
            lambert_y_coordinate = lambert_y_coordinate + int(detailed_square[len(detailed_square) // 2:]) * factor

            # transform the MBS coordinate to WGS84
            try:
                x, y = transform(crs_modified_lambert, crs_specified, lambert_x_coordinate, lambert_y_coordinate)
                return x, y
            except pyproj.exceptions.CRSError:
                pass
        except IndexError:
            pass

    def clear_annotation(self):
        """Clear QgsTextAnnotation from canvas"""

        self.project().annotationManager().clear()

    def set_annotation(self, name, crs, coordinates):
        """Define settings of QgsTextAnnotation"""

        self.clear_annotation()

        annotation = QgsTextAnnotation()

        annotation.setFrameOffsetFromReferencePoint(QPoint(1, 1))

        doc = QTextDocument()
        doc.setHtml("<p style='font-family: Yu Gothic UI; color: #FF8000; font-size: 15px;'>{}</p>".format(name))

        annotation.setDocument(doc)

        annotation.setMapPositionCrs(QgsCoordinateReferenceSystem(crs))
        annotation.setMapPosition(QgsPointXY(coordinates[0], coordinates[1]))

        marker = QgsMarkerSymbol.createSimple({"size": "3.0", "color": "darkRed", "color_border": "white"})

        annotation.setMarkerSymbol(marker)

        self.project().annotationManager().addAnnotation(annotation)

        self.iface.mapCanvas().setCenter(QgsPointXY(float(coordinates[0]), float(coordinates[1])))

    def show_coordinates(self):
        """Show output coordinate as QGSTextAnnotation"""

        in_coordinate = self.lineEdit.text()
        crs_modified_lambert = self.crs_modified_lambert()
        crs_specified = self.output_spatial_reference_system()

        failures = self.check_mbs_coordinate(in_coordinate)

        if failures != []:
            self.iface.messageBar().pushMessage("Error", "Fehler bei Koordinate {}".format(in_coordinate),
                                                level=Qgis.Critical, duration=5)
            try:
                for f in failures:
                    self.iface.messageBar().pushMessage("Error", f, level=Qgis.Critical, duration=8)
                    continue
            except TypeError:
                pass

        else:
            try:

                converted_coordinates = self.mbs_to_crs(in_coordinate, crs_modified_lambert, crs_specified)

                self.set_annotation(in_coordinate, crs_specified, converted_coordinates)

                self.iface.messageBar().pushMessage("Success",
                                                    "Transformation erfolgreich",
                                                    level=Qgis.Success, duration=3)
            except TypeError:
                self.iface.messageBar().pushMessage("Error",
                                                    " Für Koordinatentransformation bitte Zielkoordinatensystem wählen."
                                                    , level=Qgis.Critical, duration=8)

    def show_coordinates_in_window(self, x, y):
        """Open window and show coordinates"""

        self.dlg = showXYDialog()

        self.dlg.lineEdit.clear()
        self.dlg.lineEdit_2.clear()

        self.dlg.lineEdit.setText(str(x))
        self.dlg.lineEdit_2.setText(str(y))

        self.dlg.show()

    def run(self):
        """Run method that performs all the real work"""

        pass
